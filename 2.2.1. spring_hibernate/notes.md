
### Задание:

* 1. Создайте соединение к своей базе данных и схему. Запустите приложение. Проверьте, что оно полностью работает.
* 2. Создайте сущность Car с полями String model и int series, на которую будет ссылаться User с помощью связи one-to-one.
* 3. Добавьте этот класс в настройки hibernate.
* 4. Создайте несколько пользователей с машинами, добавьте их в базу данных, вытащите обратно.
* 5. В сервис добавьте метод, который с помощью hql-запроса будет доставать юзера, владеющего машиной по ее модели и серии.

---

### Пояснение **HQL** - запроса по 5-му пункту:

`SELECT u FROM User u JOIN FETCH u.car c WHERE c.model = :model AND c.series = :series`


* `SELECT u` - мы хотим выбрать объекты класса **User** (сокращение для `FROM User u`);

* `JOIN FETCH u.car c` - Это делает "жадное" (_eager_) подгружение (`JOIN FETCH`) 
связанной сущности **car** для пользователя **u**. Таким образом, Hibernate будет 
загружать и связанный объект **car**, а не только его идентификатор.

* `WHERE c.model = :model AND c.series = :series` Это условие фильтрации результатов. 
Мы указываем, что хотим выбрать только те машины, у которых модель (`model`) 
и серия (`series`) соответствуют переданным значениям (**:model** и **:series**). 
Значения этих параметров будут подставлены позже в запросе.

В результате выполнения этого запроса мы получим список пользователей (**User**), 
у которых есть машина (**car**), удовлетворяющая указанным критериям **модели** и **серии**.

---

## Памятка по примененным анотациям:

**Класс** `User`:
* `@Entity` - Указывает, что класс **User** является сущностью (_entity_), которая будет отображаться на таблицу в базе данных.
  
* `@Table(name = "users")` - Указывает имя таблицы в базе данных, которая будет соответствовать этой сущности. В моем случае, таблица называется "**users**".
  
* `@Id` - Указывает, что поле **id** является **первичным ключом** для таблицы. Первичный ключ идентифицирует уникальную запись в таблице.
  
* `@GeneratedValue(strategy = GenerationType.IDENTITY)` - Указывает способ генерации значений для первичного ключа. В данном случае, значения будут генерироваться автоматически базой данных (_identity column_).
  
* `@Column(name = "name", length = 50, nullable = false)` - Указывает, что поле **firstName** будет отображаться на столбец "**name**" в таблице. `length = 50` ограничивает длину значения в столбце до 50 символов, а `nullable = false` указывает, что поле не может быть **NULL**.
  Аналогично для полей `lastName` и `email`.
  
* `@JoinColumn(name = "fk_car_id", referencedColumnName = "id_car")` - Указывает столбец в таблице **User**, который является внешним ключом (`fk_car_id`), и столбец в таблице **Car**, на который этот внешний ключ ссылается (`id_car`).
  
* `@OneToOne` - Указывает на отношение "**один к одному**" между сущностями **User** и **Car**. Это означает, что каждый пользователь может иметь только одну машину, и каждая машина может принадлежать только одному пользователю.

* `@OneToOne(cascade = CascadeType.PERSIST)` - Каскадное сохранение `(CascadeType.PERSIST)` означает, что при сохранении **User** также будут сохранены все связанные с ним **Car**.
  `cascade = CascadeType.ALL` — означает, что операция, например, записи должна распространяться и на дочерние таблицы

* `@OneToOne(cascade = CascadeType.PERSIST, orphanRemoval = true)` - позволяет удалять объекты сироты. `orphanRemoval = true` - При удалении **родительского** объекта удаляется и **дочерний**.

* `@OneToOne(mappedBy = "contact", cascade = CascadeType.ALL)` - mappedBy — обратная сторона связи сущности. `mappedBy = "contact"` Поле под этим атрибутом не сохраняется как часть исходной сущности в базе данных, но будет доступна по запросу. (см. ниже @JoinColumn)

---

* `@SuppressWarnings("unchecked")` - Используется для подавления предупреждений компилятора о непроверенных операциях. 

* `@Repository` - Помечает класс как объект доступа к данным (_Data Access Object - DAO_) и сообщает **Spring** о необходимости создания бина этого класса для управления доступом к данным. Аннотация `@Repository` также перехватывает исключения, связанные с доступом к данным, и преобразует их в подклассы `org.springframework.dao` (например, **DataAccessException**)

* `@Transactional` - Используется для указания транзакционного поведения методов. В данном случае:
  `@Transactional` над методом **add** указывает, что этот метод должен быть выполнен в рамках транзакции. Это означает, что если происходит ошибка, транзакция будет отменена, и любые изменения, внесенные методом add, будут отменены.
  `@Transactional(readOnly = true)` над методом `listCars` указывает, что этот метод выполняется в режиме только чтения. Это означает, что метод не будет делать изменений в базе данных и может выполняться в контексте только для чтения без блокировки. **Это может повысить производительность**, поскольку в режиме только чтения нет необходимости синхронизировать изменения в базе данных.

---

### Дополнительно:

* `@Transient` — указывает, что свойство **не нужно записывать**. Значения под этой аннотацией **не записываются** в базу данных _(также не участвуют в сериализации)_. static и **final** переменные экземпляра всегда **transient**.

* `@Version` — управление версией в записи сущности. При изменении записи увеличится на 1. _Пример ниже:_

```
  @Version
  @Column(name = "version")
  private int version;```
  ```

* `@OrderBy` — указание сортировки. В примере множество кошек будет отсортировано по имени по возрастанию. _Пример ниже:_

```
@Entity
@Table(name = "cat_table")
public class Cat implements Serializable {

@OrderBy("firstName asc")
private Set catsSet;
...
}
```



